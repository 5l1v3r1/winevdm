/*
 * Thunk supports for 16-bit COM interface
 * based on unknwn.idl, objidl.idl, oleidl.idl
 */

/*
 * Copyright 2002 Ove Kaaven
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
 */

#ifndef DO_NO_IMPORTS
import "../wine/windows/wtypes.idl";
#endif

[
  local,
  object,
  uuid(00000000-0000-0000-C000-000000000046),
  pointer_default(unique)
]
interface IUnknown
{
  typedef [unique] IUnknown *LPUNKNOWN;

  HRESULT QueryInterface(
    [in] REFIID riid,
    [out, iid_is(riid)] void **ppvObject);
  ULONG AddRef();
  ULONG Release();
}

[
  object,
  uuid(00000001-0000-0000-C000-000000000046),
  pointer_default(unique)
]
interface IClassFactory : IUnknown
{
  typedef [unique] IClassFactory *LPCLASSFACTORY;

  [local]
  HRESULT CreateInstance(
    [in, unique] IUnknown *pUnkOuter,
    [in] REFIID riid,
    [out, iid_is(riid)] void **ppvObject);

  [call_as(CreateInstance)]
  HRESULT RemoteCreateInstance(
    [in] REFIID riid,
    [out, iid_is(riid)] IUnknown **ppvObject);

  [local]
  HRESULT LockServer(
    [in] BOOL fLock);

  [call_as(LockServer)]
  HRESULT RemoteLockServer(
    [in] BOOL fLock);
}

interface IStream;
interface IEnumString;
interface IRunningObjectTable;
interface IMoniker;
interface IAdviseSink;
/******************** Fundamentals ********************/

[
  local,
  object,
  uuid(00000003-0000-0000-C000-000000000046)
]
interface IMarshal : IUnknown
{
  typedef [unique] IMarshal *LPMARSHAL;

  HRESULT GetUnmarshalClass(
    [in] REFIID riid,
    [in, unique] void *pv,
    [in] DWORD dwDestContext,
    [in, unique] void *pvDestContext,
    [in] DWORD mshlflags,
    [out] CLSID *pCid);

  HRESULT GetMarshalSizeMax(
    [in] REFIID riid,
    [in, unique] void *pv,
    [in] DWORD dwDestContext,
    [in, unique] void *pvDestContext,
    [in] DWORD mshlflags,
    [out] DWORD *pSize);

  HRESULT MarshalInterface(
    [in, unique] IStream *pStm,
    [in] REFIID riid,
    [in, unique] void *pv,
    [in] DWORD dwDestContext,
    [in, unique] void *pvDestContext,
    [in] DWORD mshlflags);

  HRESULT UnmarshalInterface(
    [in, unique] IStream *pStm,
    [in] REFIID riid,
    [out] void **ppv);

  HRESULT ReleaseMarshalData(
    [in, unique] IStream *pStm);

  HRESULT DisconnectObject(
    [in] DWORD dwReserved);
}

[
  local,
  object,
  uuid(00000018-0000-0000-C000-000000000046)
]
interface IStdMarshalInfo : IUnknown
{
  typedef [unique] IStdMarshalInfo *LPSTDMARSHALINFO;

  HRESULT GetClassForHandler(
    [in] DWORD dwDestContext,
    [in, unique] void *pvDestContext,
    [out] CLSID *pClsid);
}

[
  local,
  object,
  uuid(00000019-0000-0000-C000-000000000046)
]
interface IExternalConnection : IUnknown
{
  typedef [unique] IExternalConnection *LPEXTERNALCONNECTION;

  typedef enum tagEXTCONN {
    EXTCONN_STRONG   = 0x0001,
    EXTCONN_WEAK     = 0x0002,
    EXTCONN_CALLABLE = 0x0004
  } EXTCONN;

  DWORD AddConnection(
    [in] DWORD extconn,
    [in] DWORD reserved);

  DWORD ReleaseConnection(
    [in] DWORD extconn,
    [in] DWORD reserved,
    [in] BOOL fLastReleaseCloses);
}

[
  local,
  object,
  uuid(00000002-0000-0000-C000-000000000046)
]
interface IMalloc : IUnknown
{
  typedef [unique] IMalloc *LPMALLOC;

  LPVOID Alloc(
    [in] SIZE_T cb);

  LPVOID Realloc(
    [in] LPVOID pv,
    [in] SIZE_T cb);

  void Free(
    [in] LPVOID pv);

  SIZE_T GetSize(
    [in] LPVOID pv);

  int DidAlloc(LPVOID pv);

  void HeapMinimize();
}


[
  object,
  uuid(00000100-0000-0000-C000-000000000046),
  pointer_default(unique)
]
interface IEnumUnknown : IUnknown
{
  typedef [unique] IEnumUnknown *LPENUMUNKNOWN;

  [local]
  HRESULT Next(
    [in] ULONG celt,
    [out] IUnknown **rgelt,
    [out] ULONG *pceltFetched);

  [call_as(Next)]
  HRESULT RemoteNext(
    [in] ULONG celt,
    [out, size_is(celt), length_is(*pceltFetched)]
    IUnknown **rgelt,
    [out] ULONG *pceltFetched);

  HRESULT Skip(
    [in] ULONG celt);

  HRESULT Reset();

  HRESULT Clone(
    [out] IEnumUnknown **ppenum);
}

typedef struct _COSERVERINFO {
  DWORD dwReserved1;
  LPWSTR pwszName;
  COAUTHINFO *pAuthInfo;
  DWORD dwReserved2;
} COSERVERINFO;
/******************** Monikers ********************/

[
  object,
  uuid(0000000e-0000-0000-C000-000000000046),
  pointer_default(unique)
]
interface IBindCtx : IUnknown
{
  typedef [unique] IBindCtx *LPBINDCTX;
  typedef [unique] IBindCtx *LPBC;

  typedef struct tagBIND_OPTS {
    DWORD cbStruct;
    DWORD grfFlags;
    DWORD grfMode;
    DWORD dwTickCountDeadline;
  } BIND_OPTS, *LPBIND_OPTS;

  /* FIXME: C++ crap */
  typedef struct tagBIND_OPTS2 {
    DWORD cbStruct;
    DWORD grfFlags;
    DWORD grfMode;
    DWORD dwTickCountDeadline;
    DWORD dwTrackFlags;
    DWORD dwClassContext;
    LCID  locale;
    COSERVERINFO *pServerInfo;
  } BIND_OPTS2, *LPBIND_OPTS2;

  typedef struct tagBIND_OPTS3 {
    DWORD cbStruct;
    DWORD grfFlags;
    DWORD grfMode;
    DWORD dwTickCountDeadline;
    DWORD dwTrackFlags;
    DWORD dwClassContext;
    LCID  locale;
    COSERVERINFO *pServerInfo;
    HWND hwnd;
  } BIND_OPTS3, *LPBIND_OPTS3;

  typedef enum tagBIND_FLAGS {
    BIND_MAYBOTHERUSER   = 1,
    BIND_JUSTTESTEXISTENCE = 2
  } BIND_FLAGS;

  HRESULT RegisterObjectBound(
    [in, unique] IUnknown *punk);

  HRESULT RevokeObjectBound(
    [in, unique] IUnknown *punk);

  HRESULT ReleaseBoundObjects();

  [local]
  HRESULT SetBindOptions(
    [in] BIND_OPTS *pbindopts);

  [call_as(SetBindOptions)]
  HRESULT RemoteSetBindOptions(
    [in] BIND_OPTS2 *pbindopts);

  [local]
  HRESULT GetBindOptions(
    [in, out] BIND_OPTS *pbindopts);

  [call_as(GetBindOptions)]
  HRESULT RemoteGetBindOptions(
    [in, out] BIND_OPTS2 *pbindopts);

  HRESULT GetRunningObjectTable(
    [out] IRunningObjectTable **pprot);

  HRESULT RegisterObjectParam(
    [in] LPOLESTR pszKey,
    [in, unique] IUnknown *punk);

  HRESULT GetObjectParam(
    [in] LPOLESTR pszKey,
    [out] IUnknown **ppunk);

  HRESULT EnumObjectParam(
    [out] IEnumString **ppenum);

  HRESULT RevokeObjectParam(
    [in] LPOLESTR pszKey);
}

[
  object,
  uuid(00000102-0000-0000-C000-000000000046),
  pointer_default(unique)
]
interface IEnumMoniker : IUnknown
{
  typedef [unique] IEnumMoniker *LPENUMMONIKER;

  [local]
  HRESULT Next(
    [in] ULONG celt,
    [out, size_is(celt), length_is(*pceltFetched)]
    IMoniker **rgelt,
    [out] ULONG *pceltFetched);

  [call_as(Next)]
  HRESULT RemoteNext(
    [in] ULONG celt,
    [out, size_is(celt), length_is(*pceltFetched)]
    IMoniker **rgelt,
    [out] ULONG *pceltFetched);

  HRESULT Skip(
    [in] ULONG celt);

  HRESULT Reset();

  HRESULT Clone(
    [out] IEnumMoniker **ppenum);
}

[
  object,
  uuid(00000126-0000-0000-C000-000000000046)
]
interface IRunnableObject : IUnknown
{
  typedef [unique] IRunnableObject *LPRUNNABLEOBJECT;

  HRESULT GetRunningClass(
    [out] LPCLSID lpClsid);

  HRESULT Run(
    [in] LPBINDCTX pbc);

  [local]
  BOOL IsRunning();

  [call_as(IsRunning)]
  HRESULT RemoteIsRunning();

  HRESULT LockRunning(
    [in] BOOL fLock,
    [in] BOOL fLastUnlockCloses);

  HRESULT SetContainedObject(
    [in] BOOL fContained);
}

/* GetObject is defined in wingdi.h as WINELIB_NAME_AW(GetObject),
 * which resolves to a compilation failure if WINE_NO_UNICODE_MACROS is defined,
 * but GetObject is used as a valid method name below, so we have
 * to undefine it in that case */
cpp_quote("#ifdef WINE_NO_UNICODE_MACROS")
cpp_quote("#undef GetObject")
cpp_quote("#endif")

[
  object,
  uuid(00000010-0000-0000-C000-000000000046)
]
interface IRunningObjectTable : IUnknown
{
  typedef [unique] IRunningObjectTable *LPRUNNINGOBJECTTABLE;

  HRESULT Register(
    [in] DWORD grfFlags,
    [in, unique] IUnknown *punkObject,
    [in, unique] IMoniker *pmkObjectName,
    [out] DWORD *pdwRegister);

  HRESULT Revoke(
    [in] DWORD dwRegister);

  HRESULT IsRunning(
    [in, unique] IMoniker *pmkObjectName);

  HRESULT GetObject(
    [in, unique] IMoniker *pmkObjectName,
    [out] IUnknown **ppunkObject);

  HRESULT NoteChangeTime(
    [in] DWORD dwRegister,
    [in] FILETIME *pfiletime);

  HRESULT GetTimeOfLastChange(
    [in, unique] IMoniker *pmkObjectName,
    [out] FILETIME *pfiletime);

  HRESULT EnumRunning(
    [out] IEnumMoniker **ppenumMoniker);
}

[
  object,
  uuid(0000010c-0000-0000-C000-000000000046)
]
interface IPersist : IUnknown
{
  typedef [unique] IPersist *LPPERSIST;

  HRESULT GetClassID(
    [out] CLSID *pClassID);
}

[
  object,
  uuid(00000109-0000-0000-C000-000000000046),
  pointer_default(unique)
]
interface IPersistStream : IPersist
{
  typedef [unique] IPersistStream *LPPERSISTSTREAM;

  HRESULT IsDirty();

  HRESULT Load(
    [in, unique] IStream *pStm);

  HRESULT Save(
    [in, unique] IStream *pStm,
    [in] BOOL fClearDirty);

  HRESULT GetSizeMax(
    [out] ULARGE_INTEGER *pcbSize);
}

[
  object,
  uuid(0000000f-0000-0000-C000-000000000046),
  pointer_default(unique)
]
interface IMoniker : IPersistStream
{
  typedef [unique] IMoniker *LPMONIKER;

  typedef enum tagMKSYS {
    MKSYS_NONE             = 0,
    MKSYS_GENERICCOMPOSITE = 1,
    MKSYS_FILEMONIKER      = 2,
    MKSYS_ANTIMONIKER      = 3,
    MKSYS_ITEMMONIKER      = 4,
    MKSYS_POINTERMONIKER   = 5,
    /* MKSYS_URLMONIKER       = 6, */ /* defined in urlmon.idl */
    MKSYS_CLASSMONIKER     = 7
  } MKSYS;

  typedef [v1_enum] enum tagMKREDUCE {
    MKRREDUCE_ONE         = 3 << 16,
    MKRREDUCE_TOUSER      = 2 << 16,
    MKRREDUCE_THROUGHUSER = 1 << 16,
    MKRREDUCE_ALL         = 0
  } MKRREDUCE;

  [local]
  HRESULT BindToObject(
    [in, unique] IBindCtx *pbc,
    [in, unique] IMoniker *pmkToLeft,
    [in] REFIID riidResult,
    [out, iid_is(riidResult)] void **ppvResult);

  [call_as(BindToObject)]
  HRESULT RemoteBindToObject(
    [in, unique] IBindCtx *pbc,
    [in, unique] IMoniker *pmkToLeft,
    [in] REFIID riidResult,
    [out, iid_is(riidResult)] IUnknown **ppvResult);

  [local]
  HRESULT BindToStorage(
    [in, unique] IBindCtx *pbc,
    [in, unique] IMoniker *pmkToLeft,
    [in] REFIID riid,
    [out, iid_is(riid)] void **ppvObj);

  [call_as(BindToStorage)]
  HRESULT RemoteBindToStorage(
    [in, unique] IBindCtx *pbc,
    [in, unique] IMoniker *pmkToLeft,
    [in] REFIID riid,
    [out, iid_is(riid)] IUnknown **ppvObj);

  HRESULT Reduce(
    [in, unique] IBindCtx *pbc,
    [in] DWORD dwReduceHowFar,
    [in, out, unique] IMoniker **ppmkToLeft,
    [out] IMoniker **ppmkReduced);

  HRESULT ComposeWith(
    [in, unique] IMoniker *pmkRight,
    [in] BOOL fOnlyIfNotGeneric,
    [out] IMoniker **ppmkComposite);

  HRESULT Enum(
    [in] BOOL fForward,
    [out] IEnumMoniker **ppenumMoniker);

  HRESULT IsEqual(
    [in, unique] IMoniker *pmkOtherMoniker);

  HRESULT Hash(
    [out] DWORD *pdwHash);

  HRESULT IsRunning(
    [in, unique] IBindCtx *pbc,
    [in, unique] IMoniker *pmkToLeft,
    [in, unique] IMoniker *pmkNewlyRunning);

  HRESULT GetTimeOfLastChange(
    [in, unique] IBindCtx *pbc,
    [in, unique] IMoniker *pmkToLeft,
    [out] FILETIME *pFileTime);

  HRESULT Inverse(
    [out] IMoniker **ppmk);

  HRESULT CommonPrefixWith(
    [in, unique] IMoniker *pmkOther,
    [out] IMoniker **ppmkPrefix);

  HRESULT RelativePathTo(
    [in, unique] IMoniker *pmkOther,
    [out] IMoniker **ppmkRelPath);

  HRESULT GetDisplayName(
    [in, unique] IBindCtx *pbc,
    [in, unique] IMoniker *pmkToLeft,
    [out] LPOLESTR *ppszDisplayName);

  HRESULT ParseDisplayName(
    [in, unique] IBindCtx *pbc,
    [in, unique] IMoniker *pmkToLeft,
    [in] LPOLESTR pszDisplayName,
    [out] ULONG *pchEaten,
    [out] IMoniker **ppmkOut);

  HRESULT IsSystemMoniker(
    [out] DWORD *pdwMksys);
}


[
  object,
  uuid(00000101-0000-0000-C000-000000000046),
  pointer_default(unique)
]
interface IEnumString : IUnknown
{
  typedef [unique] IEnumString *LPENUMSTRING;

  [local]
  HRESULT Next(
    [in] ULONG celt,
    [out, size_is(celt), length_is(*pceltFetched)]
    LPOLESTR *rgelt,
    [out] ULONG *pceltFetched);

  [call_as(Next)]
  HRESULT RemoteNext(
    [in] ULONG celt,
    [out, size_is(celt), length_is(*pceltFetched)]
    LPOLESTR *rgelt,
    [out] ULONG *pceltFetched);

  HRESULT Skip(
    [in] ULONG celt);

  HRESULT Reset();

  HRESULT Clone(
    [out] IEnumString **ppenum);
}

/******************** Storage ********************/

[
  object,
  uuid(0c733a30-2a1c-11ce-ade5-00aa0044773d),
  pointer_default(unique)
]
interface ISequentialStream : IUnknown
{
  [local]
  HRESULT Read(
    [out, size_is(cb), length_is(*pcbRead)]
    void *pv,
    [in] ULONG cb,
    [out] ULONG *pcbRead);

  [call_as(Read)]
  HRESULT RemoteRead(
    [out, size_is(cb), length_is(*pcbRead)]
    byte *pv,
    [in] ULONG cb,
    [out] ULONG *pcbRead);

  [local]
  HRESULT Write(
    [in, size_is(cb)] const void *pv,
    [in] ULONG cb,
    [out] ULONG *pcbWritten);

  [call_as(Write)]
  HRESULT RemoteWrite(
    [in, size_is(cb)] const byte *pv,
    [in] ULONG cb,
    [out] ULONG *pcbWritten);
}

[
  object,
  uuid(0000000c-0000-0000-C000-000000000046),
  pointer_default(unique)
]
interface IStream : ISequentialStream
{
  typedef [unique] IStream *LPSTREAM;

  typedef struct tagSTATSTG {
    LPOLESTR pwcsName;
    DWORD type;
    ULARGE_INTEGER cbSize;
    FILETIME mtime;
    FILETIME ctime;
    FILETIME atime;
    DWORD grfMode;
    DWORD grfLocksSupported;
    CLSID clsid;
    DWORD grfStateBits;
    DWORD reserved;
  } STATSTG;

  typedef enum tagSTGTY {
    STGTY_STORAGE   = 1,
    STGTY_STREAM    = 2,
    STGTY_LOCKBYTES = 3,
    STGTY_PROPERTY  = 4
  } STGTY;

  typedef enum tagSTREAM_SEEK {
    STREAM_SEEK_SET = 0,
    STREAM_SEEK_CUR = 1,
    STREAM_SEEK_END = 2
  } STREAM_SEEK;

  /* these are defined in Linux's fcntl.h,
   * undefine them to avoid conflicts */
  cpp_quote("#undef LOCK_MAND")
  cpp_quote("#undef LOCK_READ")
  cpp_quote("#undef LOCK_WRITE")
  cpp_quote("#undef LOCK_RW")

  typedef enum tagLOCKTYPE {
    LOCK_WRITE      = 1,
    LOCK_EXCLUSIVE  = 2,
    LOCK_ONLYONCE   = 4
  } LOCKTYPE;

  [local]
  HRESULT Seek(
    [in] LARGE_INTEGER dlibMove,
    [in] DWORD dwOrigin,
    [out] ULARGE_INTEGER *plibNewPosition);

  [call_as(Seek)]
  HRESULT RemoteSeek(
    [in] LARGE_INTEGER dlibMove,
    [in] DWORD dwOrigin,
    [out] ULARGE_INTEGER *plibNewPosition);

  HRESULT SetSize(
    [in] ULARGE_INTEGER libNewSize);

  [local]
  HRESULT CopyTo(
    [in, unique] IStream *pstm,
    [in] ULARGE_INTEGER cb,
    [out] ULARGE_INTEGER *pcbRead,
    [out] ULARGE_INTEGER *pcbWritten);

  [call_as(CopyTo)]
  HRESULT RemoteCopyTo(
    [in, unique] IStream *pstm,
    [in] ULARGE_INTEGER cb,
    [out] ULARGE_INTEGER *pcbRead,
    [out] ULARGE_INTEGER *pcbWritten);

  HRESULT Commit(
    [in] DWORD grfCommitFlags);

  HRESULT Revert();

  HRESULT LockRegion(
    [in] ULARGE_INTEGER libOffset,
    [in] ULARGE_INTEGER cb,
    [in] DWORD dwLockType);

  HRESULT UnlockRegion(
    [in] ULARGE_INTEGER libOffset,
    [in] ULARGE_INTEGER cb,
    [in] DWORD dwLockType);

  HRESULT Stat(
    [out] STATSTG *pstatstg,
    [in] DWORD grfStatFlag);

  HRESULT Clone(
    [out] IStream **ppstm);
}

[
  object,
  uuid(0000000d-0000-0000-C000-000000000046),
  pointer_default(unique)
]
interface IEnumSTATSTG : IUnknown
{
  typedef [unique] IEnumSTATSTG *LPENUMSTATSTG;

  [local]
  HRESULT Next(
    [in] ULONG celt,
    [out, size_is(celt), length_is(*pceltFetched)]
    STATSTG *rgelt,
    [out] ULONG *pceltFetched);

  [call_as(Next)]
  HRESULT RemoteNext(
    [in] ULONG celt,
    [out, size_is(celt), length_is(*pceltFetched)]
    STATSTG *rgelt,
    [out] ULONG *pceltFetched);

  HRESULT Skip(
    [in] ULONG celt);

  HRESULT Reset();

  HRESULT Clone(
    [out] IEnumSTATSTG **ppenum);
}

[
  object,
  uuid(0000000b-0000-0000-C000-000000000046),
  pointer_default(unique)
]
interface IStorage : IUnknown
{
  typedef [unique] IStorage *LPSTORAGE;

  typedef struct tagRemSNB {
    unsigned long ulCntStr;
    unsigned long ulCntChar;
    [size_is(ulCntChar)] OLECHAR rgString[];
  } RemSNB;

  typedef [unique] RemSNB *wireSNB;
  typedef [wire_marshal(wireSNB)] OLECHAR **SNB;

  HRESULT CreateStream(
    [in] LPCOLESTR pwcsName,
    [in] DWORD grfMode,
    [in] DWORD reserved1,
    [in] DWORD reserved2,
    [out] IStream **ppstm);

  [local]
  HRESULT OpenStream(
    [in] LPCOLESTR pwcsName,
    [in, unique] void *reserved1,
    [in] DWORD grfMode,
    [in] DWORD reserved2,
    [out] IStream **ppstm);

  [call_as(OpenStream)]
  HRESULT RemoteOpenStream(
    [in] LPCOLESTR pwcsName,
    [in] unsigned long cbReserved1,
    [in, unique, size_is(cbReserved1)] byte *reserved1,
    [in] DWORD grfMode,
    [in] DWORD reserved2,
    [out] IStream **ppstm);

  HRESULT CreateStorage(
    [in] LPCOLESTR pwcsName,
    [in] DWORD grfMode,
    [in] DWORD dwStgFmt,
    [in] DWORD reserved2,
    [out] IStorage **ppstg);

  HRESULT OpenStorage(
    [in, unique] LPCOLESTR pwcsName,
    [in, unique] IStorage *pstgPriority,
    [in] DWORD grfMode,
    [in, unique] SNB snbExclude,
    [in] DWORD reserved,
    [out] IStorage **ppstg);

  HRESULT CopyTo(
    [in] DWORD ciidExclude,
    [in, unique, size_is(ciidExclude)] const IID *rgiidExclude,
    [in, unique] SNB snbExclude,
    [in, unique] IStorage *pstgDest);

  HRESULT MoveElementTo(
    [in] LPCOLESTR pwcsName,
    [in, unique] IStorage *pstgDest,
    [in] LPCOLESTR pwcsNewName,
    [in] DWORD grfFlags);

  HRESULT Commit(
    [in] DWORD grfCommitFlags);

  HRESULT Revert();

  [local]
  HRESULT EnumElements(
    [in] DWORD reserved1,
    [in, unique, size_is(1)] void *reserved2,
    [in] DWORD reserved3,
    [out] IEnumSTATSTG **ppenum);

  [call_as(EnumElements)]
  HRESULT RemoteEnumElements(
    [in] DWORD reserved1,
    [in] unsigned long cbReserved2,
    [in, unique, size_is(cbReserved2)] byte *reserved2,
    [in] DWORD reserved3,
    [out] IEnumSTATSTG **ppenum);

  HRESULT DestroyElement(
    [in] LPCOLESTR pwcsName);

  HRESULT RenameElement(
    [in] LPCOLESTR pwcsOldName,
    [in] LPCOLESTR pwcsNewName);

  HRESULT SetElementTimes(
    [in, unique] LPCOLESTR pwcsName,
    [in, unique] const FILETIME *pctime,
    [in, unique] const FILETIME *patime,
    [in, unique] const FILETIME *pmtime);

  HRESULT SetClass(
    [in] REFCLSID clsid);

  HRESULT SetStateBits(
    [in] DWORD grfStateBits,
    [in] DWORD grfMask);

  HRESULT Stat(
    [out] STATSTG *pstatstg,
    [in] DWORD grfStatFlag);
}

[
  object,
  uuid(0000010b-0000-0000-C000-000000000046),
  pointer_default(unique)
]
interface IPersistFile : IPersist
{
  typedef [unique] IPersistFile *LPPERSISTFILE;

  HRESULT IsDirty();

  HRESULT Load(
    [in] LPCOLESTR pszFileName,
    [in] DWORD dwMode);

  HRESULT Save(
    [in, unique] LPCOLESTR pszFileName,
    [in] BOOL fRemember);

  HRESULT SaveCompleted(
    [in, unique] LPCOLESTR pszFileName);

  HRESULT GetCurFile(
    [out] LPOLESTR *ppszFileName);
}

[
  object,
  uuid(0000010a-0000-0000-C000-000000000046),
  pointer_default(unique)
]
interface IPersistStorage : IPersist
{
  typedef [unique] IPersistStorage *LPPERSISTSTORAGE;

  HRESULT IsDirty();

  HRESULT InitNew(
    [in, unique] IStorage *pStg);

  HRESULT Load(
    [in, unique] IStorage *pStg);

  HRESULT Save(
    [in, unique] IStorage *pStgSave,
    [in] BOOL fSameAsLoad);

  HRESULT SaveCompleted(
    [in, unique] IStorage *pStgNew);

  HRESULT HandsOffStorage();
}

[
  object,
  uuid(00000012-0000-0000-C000-000000000046),
  pointer_default(unique)
]
interface IRootStorage : IUnknown
{
  typedef [unique] IRootStorage *LPROOTSTORAGE;

  HRESULT SwitchToFile(
    [in] LPOLESTR pszFile);
}

[
  object,
  uuid(0000000a-0000-0000-C000-000000000046),
  pointer_default(unique)
]
interface ILockBytes : IUnknown
{
  typedef [unique] ILockBytes *LPLOCKBYTES;

  [local]
  HRESULT ReadAt(
    [in] ULARGE_INTEGER ulOffset,
    [out, size_is(cb), length_is(*pcbRead)]
    void *pv,
    [in] ULONG cb,
    [out] ULONG *pcbRead);

  [call_as(ReadAt)]
  HRESULT RemoteReadAt(
    [in] ULARGE_INTEGER ulOffset,
    [out, size_is(cb), length_is(*pcbRead)]
    byte *pv,
    [in] ULONG cb,
    [out] ULONG *pcbRead);

  [local]
  HRESULT WriteAt(
    [in] ULARGE_INTEGER ulOffset,
    [in, size_is(cb)] const void *pv,
    [in] ULONG cb,
    [out] ULONG *pcbWritten);

  [call_as(WriteAt)]
  HRESULT RemoteWriteAt(
    [in] ULARGE_INTEGER ulOffset,
    [in, size_is(cb)] const byte *pv,
    [in] ULONG cb,
    [out] ULONG *pcbWritten);

  HRESULT Flush();

  HRESULT SetSize(
    [in] ULARGE_INTEGER cb);

  HRESULT LockRegion(
    [in] ULARGE_INTEGER libOffset,
    [in] ULARGE_INTEGER cb,
    [in] DWORD dwLockType);

  HRESULT UnlockRegion(
    [in] ULARGE_INTEGER libOffset,
    [in] ULARGE_INTEGER cb,
    [in] DWORD dwLockType);

  HRESULT Stat(
    [out] STATSTG *pstatstg,
    [in] DWORD grfStatFlag);
}


/******************** Data Object ********************/

[
  object,
  uuid(00000103-0000-0000-C000-000000000046),
  pointer_default(unique)
]
interface IEnumFORMATETC : IUnknown
{
  typedef [unique] IEnumFORMATETC *LPENUMFORMATETC;

  typedef struct tagDVTARGETDEVICE {
    DWORD tdSize;
    WORD tdDriverNameOffset;
    WORD tdDeviceNameOffset;
    WORD tdPortNameOffset;
    WORD tdExtDevmodeOffset;
    [size_is(tdSize - sizeof(DWORD) - 4*sizeof(WORD))]
    BYTE tdData[];
  } DVTARGETDEVICE;

  typedef CLIPFORMAT *LPCLIPFORMAT;

  typedef struct tagFORMATETC {
    CLIPFORMAT cfFormat;
    [unique] DVTARGETDEVICE *ptd;
    DWORD dwAspect;
    LONG lindex;
    DWORD tymed;
  } FORMATETC, *LPFORMATETC;

  [local]
  HRESULT Next(
    [in] ULONG celt,
    [out, size_is(celt), length_is(*pceltFetched)]
    FORMATETC *rgelt,
    [out] ULONG *pceltFetched);

  [call_as(Next)]
  HRESULT RemoteNext(
    [in] ULONG celt,
    [out, size_is(celt), length_is(*pceltFetched)]
    FORMATETC *rgelt,
    [out] ULONG *pceltFetched);

  HRESULT Skip(
    [in] ULONG celt);

  HRESULT Reset();

  HRESULT Clone(
    [out] IEnumFORMATETC **ppenum);
}

[
  object,
  uuid(00000105-0000-0000-C000-000000000046),
  pointer_default(unique)
]
interface IEnumSTATDATA : IUnknown
{
  typedef [unique] IEnumSTATDATA *LPENUMSTATDATA;

  typedef enum tagADVF {
    ADVF_NODATA            = 1,
    ADVF_PRIMEFIRST        = 2,
    ADVF_ONLYONCE          = 4,
    ADVF_DATAONSTOP        = 64,
    ADVFCACHE_NOHANDLER    = 8,
    ADVFCACHE_FORCEBUILTIN = 16,
    ADVFCACHE_ONSAVE       = 32
  } ADVF;

  typedef struct tagSTATDATA
  {
    FORMATETC formatetc;
    DWORD advf;
    [unique] IAdviseSink *pAdvSink;
    DWORD dwConnection;
  } STATDATA, *LPSTATDATA;

  [local]
  HRESULT Next(
    [in] ULONG celt,
    [out, size_is(celt), length_is(*pceltFetched)]
    STATDATA *rgelt,
    [out] ULONG *pceltFetched);

  [call_as(Next)]
  HRESULT RemoteNext(
    [in] ULONG celt,
    [out, size_is(celt), length_is(*pceltFetched)]
    STATDATA *rgelt,
    [out] ULONG *pceltFetched);

  HRESULT Skip(
    [in] ULONG celt);

  HRESULT Reset();

  HRESULT Clone(
    [out] IEnumSTATDATA **ppenum);
}

[
  object,
  uuid(0000010f-0000-0000-C000-000000000046),
  pointer_default(unique)
]
interface IAdviseSink : IUnknown
{
  typedef IAdviseSink *LPADVISESINK;

  typedef [v1_enum] enum tagTYMED {
    TYMED_HGLOBAL  = 1,
    TYMED_FILE     = 2,
    TYMED_ISTREAM  = 4,
    TYMED_ISTORAGE = 8,
    TYMED_GDI      = 16,
    TYMED_MFPICT   = 32,
    TYMED_ENHMF    = 64,
    TYMED_NULL     = 0
  } TYMED;

  typedef struct tagRemSTGMEDIUM {
    DWORD tymed;
    DWORD dwHandleType;
    unsigned long pData;
    unsigned long pUnkForRelease;
    unsigned long cbData;
    [size_is(cbData)] byte data[];
  } RemSTGMEDIUM;

  typedef struct tagSTGMEDIUM {
    DWORD tymed;
    [switch_is(tymed)] union {
    [case(TYMED_GDI)]      HBITMAP hBitmap;
    [case(TYMED_MFPICT)]   HMETAFILEPICT hMetaFilePict;
    [case(TYMED_ENHMF)]    HENHMETAFILE hEnhMetaFile;
    [case(TYMED_HGLOBAL)]  HGLOBAL hGlobal;
    [case(TYMED_FILE)]     LPOLESTR lpszFileName;
    [case(TYMED_ISTREAM)]  IStream *pstm;
    [case(TYMED_ISTORAGE)] IStorage *pstg;
    [default]              ;
    } DUMMYUNIONNAME;
    [unique] IUnknown *pUnkForRelease;
  } uSTGMEDIUM;

/* copied from wingdi.h */
#define OBJ_PEN             1
#define OBJ_BRUSH           2
#define OBJ_DC              3
#define OBJ_METADC          4
#define OBJ_PAL             5
#define OBJ_FONT            6
#define OBJ_BITMAP          7
#define OBJ_REGION          8
#define OBJ_METAFILE        9
#define OBJ_MEMDC           10
#define OBJ_EXTPEN          11
#define OBJ_ENHMETADC       12
#define OBJ_ENHMETAFILE     13

  typedef union _GDI_OBJECT switch(DWORD ObjectType) u {
    case OBJ_BITMAP: wireHBITMAP hBitmap;
    case OBJ_PAL:    wireHPALETTE hPalette;
    default:         wireHGLOBAL hGeneric;
  } GDI_OBJECT;

  typedef struct _userSTGMEDIUM {
    union switch(DWORD tymed) u {
    case TYMED_NULL:     ;
    case TYMED_MFPICT:   wireHMETAFILEPICT hMetaFilePict;
    case TYMED_ENHMF:    wireHENHMETAFILE hHEnhMetaFile;
    case TYMED_GDI:      GDI_OBJECT *hGdiHandle;
    case TYMED_HGLOBAL:  wireHGLOBAL hGlobal;
    case TYMED_FILE:     LPOLESTR lpszFileName;
    case TYMED_ISTREAM:  BYTE_BLOB *pstm;
    case TYMED_ISTORAGE: BYTE_BLOB *pstg;
    } DUMMYUNIONNAME;
    IUnknown *pUnkForRelease;
  } userSTGMEDIUM;

  typedef [unique] userSTGMEDIUM *wireSTGMEDIUM;
  typedef [wire_marshal(wireSTGMEDIUM)] uSTGMEDIUM STGMEDIUM;

  typedef [unique] userSTGMEDIUM *wireASYNC_STGMEDIUM;
  typedef [wire_marshal(wireASYNC_STGMEDIUM)] STGMEDIUM ASYNC_STGMEDIUM;

  typedef STGMEDIUM *LPSTGMEDIUM;

  typedef struct _userFLAG_STGMEDIUM {
    long ContextFlags;
    long fPassOwnership;
    userSTGMEDIUM Stgmed;
  } userFLAG_STGMEDIUM;

  typedef [unique] userFLAG_STGMEDIUM *wireFLAG_STGMEDIUM;

  typedef [wire_marshal(wireFLAG_STGMEDIUM)] struct _FLAG_STGMEDIUM {
    long ContextFlags;
    long fPassOwnership;
    STGMEDIUM Stgmed;
  } FLAG_STGMEDIUM;

  [local]
  void OnDataChange(
    [in, unique] FORMATETC *pFormatetc,
    [in, unique] STGMEDIUM *pStgmed);

  [call_as(OnDataChange)]
  HRESULT  RemoteOnDataChange(
    [in, unique] FORMATETC *pFormatetc,
    [in, unique] ASYNC_STGMEDIUM *pStgmed);

  [local]
  void OnViewChange(
    [in] DWORD dwAspect,
    [in] LONG lindex);

  [call_as(OnViewChange)]
  HRESULT RemoteOnViewChange(
    [in] DWORD dwAspect,
    [in] LONG lindex);

  [local]
  void OnRename(
    [in] IMoniker *pmk);

  [call_as(OnRename)]
  HRESULT RemoteOnRename(
    [in] IMoniker *pmk);

  [local]
  void OnSave();

  [call_as(OnSave)]
  HRESULT RemoteOnSave();

  [local]
  void OnClose();

  [call_as(OnClose)]
  HRESULT RemoteOnClose();
}

[
  object,
  uuid(00000125-0000-0000-C000-000000000046),
  pointer_default(unique)
]
interface IAdviseSink2 : IAdviseSink
{
  typedef [unique] IAdviseSink2 *LPADVISESINK2;

  [local]
  void OnLinkSrcChange(
    [in, unique] IMoniker *pmk);

  [call_as(OnLinkSrcChange)]
  HRESULT RemoteOnLinkSrcChange(
    [in, unique] IMoniker *pmk);
}

[
  object,
  uuid(0000010e-0000-0000-C000-000000000046),
  pointer_default(unique)
]
interface IDataObject : IUnknown
{
  typedef [unique] IDataObject *LPDATAOBJECT;

  typedef enum tagDATADIR {
    DATADIR_GET = 1,
    DATADIR_SET = 2
  } DATADIR;

  [local]
  HRESULT GetData(
    [in, unique] FORMATETC *pformatetcIn,
    [out] STGMEDIUM *pmedium);

  [call_as(GetData)]
  HRESULT RemoteGetData(
    [in, unique] FORMATETC *pformatetcIn,
    [out] STGMEDIUM *pRemoteMedium);

  [local]
  HRESULT GetDataHere(
    [in, unique] FORMATETC *pformatetc,
    [in, out] STGMEDIUM *pmedium);

  [call_as(GetDataHere)]
  HRESULT RemoteGetDataHere(
    [in, unique] FORMATETC *pformatetc,
    [in, out] STGMEDIUM *pRemoteMedium);

  HRESULT QueryGetData(
    [in, unique] FORMATETC *pformatetc);

  HRESULT GetCanonicalFormatEtc(
    [in, unique] FORMATETC *pformatectIn,
    [out] FORMATETC *pformatetcOut);

  [local]
  HRESULT SetData(
    [in, unique] FORMATETC *pformatetc,
    [in, unique] STGMEDIUM *pmedium,
    [in] BOOL fRelease);

  [call_as(SetData)]
  HRESULT RemoteSetData(
    [in, unique] FORMATETC *pformatetc,
    [in, unique] FLAG_STGMEDIUM *pmedium,
    [in] BOOL fRelease);

  HRESULT EnumFormatEtc(
    [in] DWORD dwDirection,
    [out] IEnumFORMATETC **ppenumFormatEtc);

  HRESULT DAdvise(
    [in] FORMATETC *pformatetc,
    [in] DWORD advf,
    [in, unique] IAdviseSink *pAdvSink,
    [out] DWORD *pdwConnection);

  HRESULT DUnadvise(
    [in] DWORD dwConnection);

  HRESULT EnumDAdvise(
    [out] IEnumSTATDATA **ppenumAdvise);
}

[
  local,
  object,
  uuid(00000110-0000-0000-C000-000000000046)
]
interface IDataAdviseHolder : IUnknown
{
  typedef [unique] IDataAdviseHolder *LPDATAADVISEHOLDER;

  HRESULT Advise(
    [in, unique] IDataObject *pDataObject,
    [in, unique] FORMATETC *pFetc,
    [in] DWORD advf,
    [in, unique] IAdviseSink *pAdvise,
    [out] DWORD *pdwConnection);

  HRESULT Unadvise(
    [in] DWORD dwConnection);

  HRESULT EnumAdvise(
    [out] IEnumSTATDATA **ppenumAdvise);

  HRESULT SendOnDataChange(
    [in, unique] IDataObject *pDataObject,
    [in] DWORD dwReserved,
    [in] DWORD advf);
}

/******************** Remoting ********************/

[
  local,
  object,
  uuid(00000016-0000-0000-C000-000000000046)
]
interface IMessageFilter : IUnknown
{
  typedef [unique] IMessageFilter *LPMESSAGEFILTER;

  typedef enum tagCALLTYPE {
    CALLTYPE_TOPLEVEL = 1,
    CALLTYPE_NESTED   = 2,
    CALLTYPE_ASYNC    = 3,
    CALLTYPE_TOPLEVEL_CALLPENDING = 4,
    CALLTYPE_ASYNC_CALLPENDING    = 5
  } CALLTYPE;

  typedef enum tagSERVERCALL {
    SERVERCALL_ISHANDLED  = 0,
    SERVERCALL_REJECTED   = 1,
    SERVERCALL_RETRYLATER = 2
  } SERVERCALL;

  typedef enum tagPENDINGTYPE {
    PENDINGTYPE_TOPLEVEL = 1,
    PENDINGTYPE_NESTED   = 2
  } PENDINGTYPE;

  typedef enum tagPENDINGMSG {
    PENDINGMSG_CANCELCALL     = 0,
    PENDINGMSG_WAITNOPROCESS  = 1,
    PENDINGMSG_WAITDEFPROCESS = 2
  } PENDINGMSG;

  typedef struct tagINTERFACEINFO {
    IUnknown *pUnk;
    IID iid;
    WORD wMethod;
  } INTERFACEINFO, *LPINTERFACEINFO;

  DWORD HandleInComingCall(
    [in] DWORD dwCallType,
    [in] HTASK htaskCaller,
    [in] DWORD dwTickCount,
    [in] LPINTERFACEINFO lpInterfaceInfo);

  DWORD RetryRejectedCall(
    [in] HTASK htaskCallee,
    [in] DWORD dwTickCount,
    [in] DWORD dwRejectType);

  DWORD MessagePending(
    [in] HTASK htaskCallee,
    [in] DWORD dwTickCount,
    [in] DWORD dwPendingType);
}




/******************** Connection Points ********************/


cpp_quote("#endif /* defined USE_COM_CONTEXT_DEF */")


/* OLEIDL.IDL */



interface IOleInPlaceActiveObject;

cpp_quote("#include <winuser.h>")


/*****************************************************************************
 * IOleWindow interface
 */
[
    object,
    uuid(00000114-0000-0000-c000-000000000046),
    pointer_default(unique)
]
interface IOleWindow : IUnknown
{
    typedef [unique] IOleWindow *LPOLEWINDOW;

    HRESULT GetWindow(
        [out] HWND *phwnd);

    HRESULT ContextSensitiveHelp(
        [in] BOOL fEnterMode);
}


/*****************************************************************************
 * IOleInPlaceObject interface
 */
[
    object,
    uuid(00000113-0000-0000-c000-000000000046),
    pointer_default(unique)
]
interface IOleInPlaceObject : IOleWindow
{
    typedef [unique] IOleInPlaceObject *LPOLEINPLACEOBJECT;

    HRESULT InPlaceDeactivate();

    HRESULT UIDeactivate();

    HRESULT SetObjectRects(
        [in] LPCRECT lprcPosRect,
        [in] LPCRECT lprcClipRect);

    HRESULT ReactivateAndUndo();
}


/*****************************************************************************
 * IOleInPlaceUIWindow interface
 */
[
    object,
    uuid(00000115-0000-0000-c000-000000000046),
    pointer_default(unique)
]

interface IOleInPlaceUIWindow : IOleWindow
{
    typedef [unique] IOleInPlaceUIWindow *LPOLEINPLACEUIWINDOW;

    typedef RECT BORDERWIDTHS;
    typedef LPRECT LPBORDERWIDTHS;
    typedef LPCRECT LPCBORDERWIDTHS;

    HRESULT GetBorder(
        [out] LPRECT lprectBorder);

    HRESULT RequestBorderSpace(
        [in, unique] LPCBORDERWIDTHS pborderwidths);

    HRESULT SetBorderSpace(
        [in, unique] LPCBORDERWIDTHS pborderwidths);

    HRESULT SetActiveObject(
        [in, unique] IOleInPlaceActiveObject *pActiveObject,
        [in, string, unique] LPCOLESTR pszObjName);
}


/* avoid conflict with Wine Unicode macros */
cpp_quote("#ifdef WINE_NO_UNICODE_MACROS")
cpp_quote("#undef TranslateAccelerator")
cpp_quote("#endif")

/*****************************************************************************
 * IOleInPlaceFrame interface
 */
[
    object,
    uuid(00000116-0000-0000-c000-000000000046),
    pointer_default(unique)
]
interface IOleInPlaceFrame : IOleInPlaceUIWindow
{
    typedef [unique] IOleInPlaceFrame *LPOLEINPLACEFRAME;

    typedef struct tagOleInPlaceFrameInfo
    {
        UINT cb;
        BOOL fMDIApp;
        HWND hwndFrame;
        HACCEL haccel;
        UINT cAccelEntries;
    } OLEINPLACEFRAMEINFO, *LPOLEINPLACEFRAMEINFO;

    typedef struct  tagOleMenuGroupWidths
    {
        LONG width[ 6 ];
    } OLEMENUGROUPWIDTHS, *LPOLEMENUGROUPWIDTHS;

    typedef HGLOBAL HOLEMENU;

    HRESULT InsertMenus(
        [in] HMENU hmenuShared,
        [in,out] LPOLEMENUGROUPWIDTHS lpMenuWidths);

    HRESULT SetMenu(
        [in] HMENU hmenuShared,
        [in] HOLEMENU holemenu,
        [in] HWND hwndActiveObject);

    HRESULT RemoveMenus(
        [in] HMENU hmenuShared);

    HRESULT SetStatusText(
        [in, unique] LPCOLESTR pszStatusText);

    HRESULT EnableModeless(
        [in] BOOL fEnable);

    HRESULT TranslateAccelerator(
        [in] LPMSG lpmsg,
        [in] WORD wID);
}


/*****************************************************************************
 * IOleInPlaceActiveObject interface
 */
[
    object,
    uuid(00000117-0000-0000-c000-000000000046)
]
interface IOleInPlaceActiveObject : IOleWindow
{
    typedef [unique] IOleInPlaceActiveObject *LPOLEINPLACEACTIVEOBJECT;

    [local]
    HRESULT TranslateAccelerator(
        [in] LPMSG lpmsg);

    [call_as(TranslateAccelerator)]
    HRESULT RemoteTranslateAccelerator();

    HRESULT OnFrameWindowActivate(
        [in] BOOL fActivate);

    HRESULT OnDocWindowActivate(
        [in] BOOL fActivate);

    [local]
    HRESULT ResizeBorder(
        [in] LPCRECT prcBorder,
        [in, unique] IOleInPlaceUIWindow *pUIWindow,
        [in] BOOL fFrameWindow);

    [call_as(ResizeBorder)]
    HRESULT RemoteResizeBorder(
        [in] LPCRECT prcBorder,
        [in] REFIID riid,
        [in, unique, iid_is(riid)] IOleInPlaceUIWindow *pUIWindow,
        [in] BOOL fFrameWindow);

    HRESULT EnableModeless(
        [in] BOOL fEnable);
}


/*****************************************************************************
 * IOleInPlaceSite interface
 */
[
    object,
    uuid(00000119-0000-0000-c000-000000000046),
    pointer_default(unique)
]
interface IOleInPlaceSite : IOleWindow
{
    typedef [unique] IOleInPlaceSite *LPOLEINPLACESITE;

    HRESULT CanInPlaceActivate();
    HRESULT OnInPlaceActivate();
    HRESULT OnUIActivate();

    HRESULT GetWindowContext(
        [out] IOleInPlaceFrame **ppFrame,
        [out] IOleInPlaceUIWindow **ppDoc,
        [out] LPRECT lprcPosRect,
        [out] LPRECT lprcClipRect,
        [in, out] LPOLEINPLACEFRAMEINFO lpFrameInfo);

    HRESULT Scroll(
        [in] SIZE scrollExtent);

    HRESULT OnUIDeactivate(
        [in] BOOL fUndoable);

    HRESULT OnInPlaceDeactivate();
    HRESULT DiscardUndoState();
    HRESULT DeactivateAndUndo();

    HRESULT OnPosRectChange(
        [in] LPCRECT lprcPosRect);
}


/*****************************************************************************
 * IParseDisplayName interface
 */
[
    object,
    uuid(0000011a-0000-0000-c000-000000000046),
    pointer_default(unique)
]
interface IParseDisplayName : IUnknown
{
    typedef [unique] IParseDisplayName *LPPARSEDISPLAYNAME;

    HRESULT ParseDisplayName(
        [in, unique] IBindCtx *pbc,
        [in] LPOLESTR pszDisplayName,
        [out] ULONG *pchEaten,
        [out] IMoniker **ppmkOut);
}


/*****************************************************************************
 * IOleContainer interface
 */
[
    object,
    uuid(0000011b-0000-0000-c000-000000000046),
    pointer_default(unique)
]
interface IOleContainer : IParseDisplayName
{
    typedef [unique] IOleContainer *LPOLECONTAINER;

    HRESULT EnumObjects(
        [in] DWORD grfFlags,
        [out] IEnumUnknown **ppenum);

    HRESULT LockContainer(
        [in] BOOL fLock);
}


/*****************************************************************************
 * IOleItemContainer interface
 */
[
    object,
    uuid(0000011c-0000-0000-c000-000000000046),
    pointer_default(unique)
]
interface IOleItemContainer : IOleContainer
{
    typedef [unique] IOleItemContainer *LPOLEITEMCONTAINER;

    typedef enum tagBINDSPEED
    {
	BINDSPEED_INDEFINITE = 1,
	BINDSPEED_MODERATE = 2,
	BINDSPEED_IMMEDIATE = 3
    } BINDSPEED;

    typedef enum tagOLECONTF
    {
	OLECONTF_EMBEDDINGS = 1,
	OLECONTF_LINKS = 2,
	OLECONTF_OTHERS = 4,
	OLECONTF_ONLYUSER = 8,
	OLECONTF_ONLYIFRUNNING = 16
    } OLECONTF;

cpp_quote("#ifdef WINE_NO_UNICODE_MACROS")
cpp_quote("#undef GetObject")
cpp_quote("#endif")
    HRESULT GetObject(
        [in] LPOLESTR pszItem,
        [in] DWORD dwSpeedNeeded,
        [in, unique] IBindCtx *pbc,
        [in] REFIID riid,
        [out, iid_is(riid)] void **ppvObject);

    HRESULT GetObjectStorage(
        [in] LPOLESTR pszItem,
        [in, unique] IBindCtx *pbc,
        [in] REFIID riid,
        [out, iid_is(riid)] void **ppvStorage);

    HRESULT IsRunning(
        [in] LPOLESTR pszItem);
}


/*****************************************************************************
 * IOleLink interface
 */
[
    object,
    uuid(0000011d-0000-0000-c000-000000000046)
]
interface IOleLink : IUnknown
{
    typedef [unique] IOleLink *LPOLELINK;

    typedef enum tagOLEUPDATE
    {
	OLEUPDATE_ALWAYS = 1,
	OLEUPDATE_ONCALL = 3
    } OLEUPDATE, *POLEUPDATE, *LPOLEUPDATE;

    typedef enum tagOLELINKBIND
    {
	OLELINKBIND_EVENIFCLASSDIFF = 1
    } OLELINKBIND;

    HRESULT SetUpdateOptions(
        [in] DWORD dwUpdateOpt);

    HRESULT GetUpdateOptions(
        [out] DWORD *pdwUpdateOpt);

    HRESULT SetSourceMoniker(
        [in, unique] IMoniker *pmk,
        [in] REFCLSID rclsid);

    HRESULT GetSourceMoniker(
        [out] IMoniker **ppmk);

    HRESULT SetSourceDisplayName(
        [in]LPCOLESTR pszStatusText);

    HRESULT GetSourceDisplayName(
        [out] LPOLESTR *ppszDisplayName);

    HRESULT BindToSource(
        [in] DWORD bindflags,
        [in, unique] IBindCtx *pbc);

    HRESULT BindIfRunning();

    HRESULT GetBoundSource(
        [out] IUnknown **ppunk);

    HRESULT UnbindSource();

    HRESULT Update(
        [in, unique] IBindCtx *pbc);
}


/*****************************************************************************
 * IOleClientSite interface
 */
[
    object,
    uuid(00000118-0000-0000-c000-000000000046),
    pointer_default(unique)
]
interface IOleClientSite : IUnknown
{
    typedef [unique] IOleClientSite * LPOLECLIENTSITE;

    HRESULT SaveObject();

    HRESULT GetMoniker(
        [in] DWORD dwAssign,
        [in] DWORD dwWhichMoniker,
        [out] IMoniker **ppmk);

    HRESULT GetContainer(
        [out] IOleContainer **ppContainer);

    HRESULT ShowObject();

    HRESULT OnShowWindow(
        [in] BOOL fShow);

    HRESULT RequestNewObjectLayout();
}


/*****************************************************************************
 * IOleCache interface
 */
[
    object,
    uuid(0000011e-0000-0000-c000-000000000046),
    pointer_default(unique)
]
interface IOleCache : IUnknown
{
    typedef [unique] IOleCache *LPOLECACHE;

    HRESULT Cache(
        [in, unique] FORMATETC *pformatetc,
        [in] DWORD advf,
        [out] DWORD *pdwConnection);

    HRESULT Uncache(
        [in] DWORD dwConnection);

    HRESULT EnumCache(
        [out] IEnumSTATDATA **ppenumSTATDATA);

    HRESULT InitCache(
        [in, unique] IDataObject *pDataObject);

    HRESULT SetData(
        [in, unique] FORMATETC *pformatetc,
        [in, unique] STGMEDIUM *pmedium,
        [in] BOOL fRelease);
}


/*****************************************************************************
 * IOleCache2 interface
 */
[
    object,
    uuid(00000128-0000-0000-c000-000000000046),
    pointer_default(unique)
]
interface IOleCache2 : IOleCache
{
    typedef [unique] IOleCache2 *LPOLECACHE2;

    const DWORD UPDFCACHE_NODATACACHE = 0x00000001;
    const DWORD UPDFCACHE_ONSAVECACHE = 0x00000002;
    const DWORD UPDFCACHE_ONSTOPCACHE = 0x00000004;
    const DWORD UPDFCACHE_NORMALCACHE = 0x00000008;
    const DWORD UPDFCACHE_IFBLANK     = 0x00000010;
    const DWORD UPDFCACHE_ONLYIFBLANK = 0x80000000;

    const DWORD UPDFCACHE_IFBLANKORONSAVECACHE = (UPDFCACHE_IFBLANK | UPDFCACHE_ONSAVECACHE);
    const DWORD UPDFCACHE_ALL = ((DWORD)(~(UPDFCACHE_ONLYIFBLANK)));
    const DWORD UPDFCACHE_ALLBUTNODATACACHE = (UPDFCACHE_ALL & ((DWORD)(~UPDFCACHE_NODATACACHE)));

    typedef enum tagDISCARDCACHE
    {
        DISCARDCACHE_SAVEIFDIRTY = 0,
        DISCARDCACHE_NOSAVE =  1
    } DISCARDCACHE;

    [local]
    HRESULT UpdateCache(
        [in] LPDATAOBJECT pDataObject,
        [in] DWORD grfUpdf,
        [in] LPVOID pReserved);

    [call_as(UpdateCache)]
    HRESULT RemoteUpdateCache(
        [in] LPDATAOBJECT pDataObject,
        [in] DWORD grfUpdf,
        [in] LONG_PTR pReserved);

    HRESULT DiscardCache(
        [in] DWORD dwDiscardOptions);
}


/*****************************************************************************
 * IOleCacheControl interface
 */
[
    object,
    uuid(00000129-0000-0000-c000-000000000046)
]
interface IOleCacheControl : IUnknown
{
    typedef [unique] IOleCacheControl *LPOLECACHECONTROL;

    HRESULT OnRun(
        LPDATAOBJECT pDataObject);

    HRESULT OnStop();
}


/*****************************************************************************
 *  IEnumOLEVERB interface
 */
[
    object,
    uuid(00000104-0000-0000-c000-000000000046),
    pointer_default(unique)
]
interface IEnumOLEVERB : IUnknown
{
    typedef [unique] IEnumOLEVERB *LPENUMOLEVERB;

    typedef struct tagOLEVERB
    {
	LONG lVerb;
	LPOLESTR lpszVerbName;
	DWORD fuFlags;
	DWORD grfAttribs;
    } OLEVERB, *LPOLEVERB;

    typedef enum tagOLEVERBATTRIB
    {
	OLEVERBATTRIB_NEVERDIRTIES = 1,
	OLEVERBATTRIB_ONCONTAINERMENU = 2
    } OLEVERBATTRIB;

    [local]
    HRESULT Next(
        [in] ULONG celt,
        [out, size_is(celt), length_is(*pceltFetched)] LPOLEVERB rgelt,
        [out] ULONG *pceltFetched);

    [call_as(Next)]
    HRESULT RemoteNext(
        [in] ULONG celt,
        [out, size_is(celt), length_is(*pceltFetched)] LPOLEVERB rgelt,
        [out] ULONG *pceltFetched);

    HRESULT Skip(
        [in] ULONG celt);

    HRESULT Reset();

    HRESULT Clone(
        [out] IEnumOLEVERB **ppenum);
}


/*****************************************************************************
 * IOleObject interface
 */
[
    object,
    uuid(00000112-0000-0000-c000-000000000046),
    pointer_default(unique)
]
interface IOleObject : IUnknown
{
    typedef [unique] IOleObject *LPOLEOBJECT;

    typedef enum tagOLEGETMONIKER
    {
	OLEGETMONIKER_ONLYIFTHERE = 1,
	OLEGETMONIKER_FORCEASSIGN = 2,
	OLEGETMONIKER_UNASSIGN = 3,
	OLEGETMONIKER_TEMPFORUSER = 4
    } OLEGETMONIKER;

    typedef enum tagOLEWHICHMK
    {
	OLEWHICHMK_CONTAINER = 1,
	OLEWHICHMK_OBJREL = 2,
	OLEWHICHMK_OBJFULL = 3
    } OLEWHICHMK;

    typedef enum tagUSERCLASSTYPE
    {
	USERCLASSTYPE_FULL = 1,
	USERCLASSTYPE_SHORT = 2,
	USERCLASSTYPE_APPNAME = 3
    } USERCLASSTYPE;

    typedef enum tagOLEMISC
    {
	OLEMISC_RECOMPOSEONRESIZE = 0x1,
	OLEMISC_ONLYICONIC = 0x2,
	OLEMISC_INSERTNOTREPLACE = 0x4,
	OLEMISC_STATIC = 0x8,
	OLEMISC_CANTLINKINSIDE = 0x10,
	OLEMISC_CANLINKBYOLE1 = 0x20,
	OLEMISC_ISLINKOBJECT = 0x40,
	OLEMISC_INSIDEOUT = 0x80,
	OLEMISC_ACTIVATEWHENVISIBLE = 0x100,
	OLEMISC_RENDERINGISDEVICEINDEPENDENT = 0x200,
	OLEMISC_INVISIBLEATRUNTIME = 0x400,
	OLEMISC_ALWAYSRUN = 0x800,
	OLEMISC_ACTSLIKEBUTTON = 0x1000,
	OLEMISC_ACTSLIKELABEL = 0x2000,
	OLEMISC_NOUIACTIVATE = 0x4000,
	OLEMISC_ALIGNABLE = 0x8000,
	OLEMISC_SIMPLEFRAME = 0x10000,
	OLEMISC_SETCLIENTSITEFIRST = 0x20000,
	OLEMISC_IMEMODE = 0x40000,
	OLEMISC_IGNOREACTIVATEWHENVISIBLE = 0x80000,
	OLEMISC_WANTSTOMENUMERGE = 0x100000,
	OLEMISC_SUPPORTSMULTILEVELUNDO = 0x200000
    } OLEMISC;

    typedef enum tagOLECLOSE
    {
	OLECLOSE_SAVEIFDIRTY = 0,
	OLECLOSE_NOSAVE = 1,
	OLECLOSE_PROMPTSAVE = 2
    } OLECLOSE;

    HRESULT SetClientSite(
        [in, unique] IOleClientSite *pClientSite);

    HRESULT GetClientSite(
        [out] IOleClientSite **ppClientSite);

    HRESULT SetHostNames(
        [in] LPCOLESTR szContainerApp,
        [in, unique] LPCOLESTR szContainerObj);

    HRESULT Close(
        [in] DWORD dwSaveOption);

    HRESULT SetMoniker(
        [in] DWORD dwWhichMoniker,
        [in, unique] IMoniker *pmk);

    HRESULT GetMoniker(
        [in] DWORD dwAssign,
        [in] DWORD dwWhichMoniker,
        [out] IMoniker **ppmk);

    HRESULT InitFromData(
        [in, unique] IDataObject *pDataObject,
        [in] BOOL fCreation,
        [in] DWORD dwReserved);

    HRESULT GetClipboardData(
        [in] DWORD dwReserved,
        [out] IDataObject **ppDataObject);

    HRESULT DoVerb(
        [in] LONG iVerb,
        [in, unique] LPMSG lpmsg,
        [in, unique] IOleClientSite *pActiveSite,
        [in] LONG lindex,
        [in] HWND hwndParent,
        [in, unique] LPCRECT lprcPosRect);

    HRESULT EnumVerbs(
        [out] IEnumOLEVERB **ppEnumOleVerb);

    HRESULT Update();

    HRESULT IsUpToDate();

    HRESULT GetUserClassID(
        [out] CLSID *pClsid);

    HRESULT GetUserType(
        [in] DWORD dwFormOfType,
        [out] LPOLESTR *pszUserType);

    HRESULT SetExtent(
        [in] DWORD dwDrawAspect,
        [in] SIZEL *psizel);

    HRESULT GetExtent(
        [in] DWORD dwDrawAspect,
        [out] SIZEL *psizel);

    HRESULT Advise(
        [in, unique] IAdviseSink *pAdvSink,
        [out] DWORD *pdwConnection);

    HRESULT Unadvise(
        [in] DWORD dwConnection);

    HRESULT EnumAdvise(
        [out] IEnumSTATDATA **ppenumAdvise);

    HRESULT GetMiscStatus(
        [in] DWORD dwAspect,
        [out] DWORD *pdwStatus);

    HRESULT SetColorScheme(
        [in] LOGPALETTE *pLogpal);
}


/*****************************************************************************
 * IOleAdviseHolder interface
 */
[
    local,
    object,
    uuid(00000111-0000-0000-c000-000000000046)
]
interface IOleAdviseHolder : IUnknown
{
    typedef [unique] IOleAdviseHolder * LPOLEADVISEHOLDER;

    HRESULT Advise(
        [in, unique] IAdviseSink *pAdvise,
        [out] DWORD *pdwConnection);

    HRESULT Unadvise(
        [in] DWORD dwConnection);

    HRESULT EnumAdvise(
        [out] IEnumSTATDATA **ppenumAdvise);

    HRESULT SendOnRename(
        [in, unique] IMoniker *pmk);

    HRESULT SendOnSave();
    HRESULT SendOnClose();
}


/*****************************************************************************
 * IContinue interface
 */
[
    object,
    uuid(0000012a-0000-0000-c000-000000000046)
]
interface IContinue : IUnknown
{
    HRESULT FContinue();
}


/*****************************************************************************
 * IViewObject interface
 */
[
    object,
    uuid(0000010d-0000-0000-c000-000000000046)
]
interface IViewObject : IUnknown
{
    typedef [unique] IViewObject *LPVIEWOBJECT;
    typedef struct IViewObjectCallback IViewObjectCallback;

    [local]
    HRESULT Draw(
        [in] DWORD dwDrawAspect,
        [in] LONG lindex,
        [in, unique] void * pvAspect,
        [in, unique] DVTARGETDEVICE *ptd,
        [in] HDC hdcTargetDev,
        [in] HDC hdcDraw,
        [in] LPCRECTL lprcBounds,
        [in, unique] LPCRECTL lprcWBounds,
        [in] IViewObjectCallback/*BOOL (*pfnContinue)(ULONG_PTR dwContinue)*/,
        [in] ULONG_PTR dwContinue);

    [call_as(Draw)]
    HRESULT RemoteDraw(
        [in] DWORD dwDrawAspect,
        [in] LONG lindex,
        [in] ULONG_PTR pvAspect,
        [in, unique] DVTARGETDEVICE *ptd,
        [in] ULONG_PTR hdcTargetDev,
        [in] ULONG_PTR hdcDraw,
        [in] LPCRECTL lprcBounds,
        [in, unique] LPCRECTL lprcWBounds,
        [in] IContinue *pContinue);

    [local]
    HRESULT GetColorSet(
        [in] DWORD dwDrawAspect,
        [in] LONG lindex,
        [in, unique] void *pvAspect,
        [in, unique] DVTARGETDEVICE *ptd,
        [in] HDC hicTargetDev,
        [out] LOGPALETTE **ppColorSet);

    [call_as(GetColorSet)]
    HRESULT RemoteGetColorSet(
        [in] DWORD dwDrawAspect,
        [in] LONG lindex,
        [in] ULONG_PTR pvAspect,
        [in, unique] DVTARGETDEVICE *ptd,
        [in] ULONG_PTR hicTargetDev,
        [out] LOGPALETTE **ppColorSet);

    [local]
    HRESULT Freeze(
        [in] DWORD dwDrawAspect,
        [in] LONG lindex,
        [in, unique] void *pvAspect,
        [out] DWORD *pdwFreeze);

    [call_as(Freeze)]
    HRESULT RemoteFreeze(
        [in] DWORD dwDrawAspect,
        [in] LONG lindex,
        [in] ULONG_PTR pvAspect,
        [out] DWORD *pdwFreeze);

    HRESULT Unfreeze(
        [in] DWORD dwFreeze);

    HRESULT SetAdvise(
        [in] DWORD aspects,
        [in] DWORD advf,
        [in, unique] IAdviseSink *pAdvSink);

    [local]
    HRESULT GetAdvise(
        [out, unique] DWORD *pAspects,
        [out, unique] DWORD *pAdvf,
        [out] IAdviseSink **ppAdvSink);

    [call_as(GetAdvise)]
    HRESULT RemoteGetAdvise(
        [out] DWORD *pAspects,
        [out] DWORD *pAdvf,
        [out] IAdviseSink **ppAdvSink);
}


/*****************************************************************************
 * IViewObject2 interface
 */
[
    object,
    uuid(00000127-0000-0000-c000-000000000046)
]
interface IViewObject2 : IViewObject
{
    typedef [unique] IViewObject2 *LPVIEWOBJECT2;

    HRESULT GetExtent(
        [in]  DWORD dwDrawAspect,
        [in]  LONG lindex,
        [in, unique]  DVTARGETDEVICE* ptd,
        [out] LPSIZEL lpsizel);
}


/*****************************************************************************
 * IDropSource interface
 */
[
    local,
    object,
    uuid(00000121-0000-0000-c000-000000000046)
]
interface IDropSource : IUnknown
{
    typedef [unique] IDropSource *LPDROPSOURCE;

    HRESULT QueryContinueDrag(
        [in] BOOL fEscapePressed,
        [in] DWORD grfKeyState);

    HRESULT GiveFeedback(
        [in] DWORD dwEffect);
}


/*****************************************************************************
 * IDropTarget interface
 */
[
    object,
    uuid(00000122-0000-0000-c000-000000000046),
    pointer_default(unique)
]
interface IDropTarget : IUnknown
{
    typedef [unique] IDropTarget *LPDROPTARGET;

    const DWORD MK_ALT = 0x20;
    const DWORD DROPEFFECT_NONE = 0;
    const DWORD DROPEFFECT_COPY = 1;
    const DWORD DROPEFFECT_MOVE = 2;
    const DWORD DROPEFFECT_LINK = 4;
    const DWORD DROPEFFECT_SCROLL = 0x80000000;
    const DWORD DD_DEFSCROLLINSET = 11;
    const DWORD DD_DEFSCROLLDELAY = 50;
    const DWORD DD_DEFSCROLLINTERVAL = 50;
    const DWORD DD_DEFDRAGDELAY = 200;
    const DWORD DD_DEFDRAGMINDIST = 2;

    HRESULT DragEnter(
        [in, unique] IDataObject *pDataObj,
        [in] DWORD grfKeyState,
        [in] POINTL pt,
        [in, out] DWORD *pdwEffect);

    HRESULT DragOver(
        [in] DWORD grfKeyState,
        [in] POINTL pt,
        [in, out] DWORD *pdwEffect);

    HRESULT DragLeave();

    HRESULT Drop(
        [in, unique] IDataObject *pDataObj,
        [in] DWORD grfKeyState,
        [in] POINTL pt,
        [in, out] DWORD *pdwEffect);
}
